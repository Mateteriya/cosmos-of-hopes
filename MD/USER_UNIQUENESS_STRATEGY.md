# Стратегия уникальности пользователей и ограничений

## Текущая проблема
Сейчас используется `TEMP_USER_ID = 'test_user_' + Date.now()`, который генерируется заново при каждой загрузке страницы. Это означает, что:
- Пользователь не может быть идентифицирован при повторном заходе
- Нельзя отследить, создал ли он уже шар
- Нельзя проверить, лайкнул ли он кого-то ранее

## Решение 1: Сохранение ID пользователя в localStorage

### Реализация:
1. Создать утилиту `lib/userId.ts` для управления ID пользователя
2. При первом заходе генерировать уникальный ID и сохранять в `localStorage`
3. При повторном заходе загружать ID из `localStorage`
4. ID должен быть уникальным и постоянным для каждого браузера/устройства

### Преимущества:
- ✅ Простота реализации
- ✅ Работает offline
- ✅ ID сохраняется даже после закрытия браузера

### Недостатки:
- ⚠️ Если пользователь очистит localStorage, он получит новый ID
- ⚠️ В разных браузерах/устройствах будет разный ID (это нормально - один человек = один браузер = один шар)

---

## Ответы на вопросы

### Вопрос 1: Как скрыть свой шар на общей ёлке до лайка?

**Решение:** Уже реализовано частично!
- В `VirtualTree.tsx` есть фильтрация: `toys.filter(t => t.user_id !== currentUserId)`
- Это срабатывает только если `userHasLiked === false`
- Нужно убедиться, что проверка `hasUserLikedAnyBall` работает корректно

**Что нужно улучшить:**
1. Убедиться, что проверка лайков работает с постоянным ID пользователя
2. После первого лайка автоматически показывать свой шар на ёлке

---

### Вопрос 2: Что происходит после первого лайка?

**Предложение:**

1. **Автоматическое обновление ёлки:**
   - После первого лайка (`handleBallLike`) вызывать `checkUserLikes()`
   - Если `userHasLiked` становится `true`, обновить список `toys` (добавить свой шар)
   - Можно добавить анимацию появления своего шара (например, пульсация или свечение)

2. **Выделение своего шара:**
   - В компоненте `BallOnTree` проверить `isUserBall` prop
   - Добавить визуальные эффекты:
     - **Пульсация/свечение** - небольшое увеличение яркости и размера периодически
     - **Подсветка** - дополнительный цветной ореол вокруг шара
     - **Анимация** - плавное появление при первой загрузке после лайка

3. **Визуальные эффекты (предложение):**
   ```typescript
   // В BallOnTree компоненте
   {isUserBall && (
     <mesh position={[0, 0, 0]}>
       {/* Подсветка */}
       <pointLight intensity={0.5} color="#ffd700" />
       {/* Анимированное свечение */}
       <meshBasicMaterial color="#ffd700" opacity={0.3} />
     </mesh>
   )}
   ```

---

### Вопрос 3: Как ограничить создание нескольких шаров одним пользователем?

**Предложение:**

1. **Проверка при создании шара:**
   - В `app/constructor/page.tsx` перед сохранением проверить, есть ли уже шар у этого пользователя
   - Создать функцию `hasUserCreatedToy(userId: string): Promise<boolean>`
   - Если шар уже есть - показать предупреждение и блокировать сохранение

2. **Отображение существующего шара:**
   - Если пользователь пытается создать второй шар, показать модальное окно:
     - "У вас уже есть шар на ёлке!"
     - Кнопка "Посмотреть свой шар" (переход на ёлку с фильтром)
     - Кнопка "Редактировать свой шар" (переход на редактор с загрузкой существующего шара)

3. **Ограничение по браузеру/устройству:**
   - ✅ Один браузер = один ID = один шар
   - ✅ Если пользователь откроет приложение в другом браузере, он получит новый ID и сможет создать новый шар
   - ⚠️ Это нормальное поведение - невозможно полностью предотвратить создание нескольких шаров без авторизации

4. **Дополнительная защита (опционально):**
   - Можно добавить проверку по IP-адресу (но это не идеально)
   - Можно добавить проверку по fingerprint браузера (сложнее)
   - **Лучший вариант:** Позже интегрировать Telegram авторизацию

---

## План реализации

### Шаг 1: Создать утилиту для управления ID пользователя
- [ ] Создать `lib/userId.ts`
- [ ] Функция `getOrCreateUserId()` - получить или создать ID
- [ ] Функция `getUserId()` - просто получить ID (может вернуть null)

### Шаг 2: Заменить TEMP_USER_ID во всех компонентах
- [ ] `app/tree/page.tsx` - использовать `getOrCreateUserId()`
- [ ] `app/constructor/page.tsx` - использовать `getOrCreateUserId()`
- [ ] Все другие места, где используется `TEMP_USER_ID`

### Шаг 3: Добавить проверку существующего шара
- [ ] Создать функцию `getUserToy(userId: string): Promise<Toy | null>`
- [ ] В конструкторе перед сохранением проверять существующий шар
- [ ] Показывать предупреждение, если шар уже существует

### Шаг 4: Улучшить визуальное выделение своего шара
- [ ] Добавить визуальные эффекты в `BallOnTree` компонент
- [ ] Пульсация, свечение, подсветка для `isUserBall === true`
- [ ] Анимация появления после первого лайка

### Шаг 5: Улучшить логику показа/скрытия шаров
- [ ] Убедиться, что фильтрация работает корректно
- [ ] Автоматически обновлять список шаров после первого лайка
- [ ] Добавить плавную анимацию появления своего шара

---

## Примеры кода

### lib/userId.ts
```typescript
const USER_ID_KEY = 'cosmos_of_hopes_user_id';

export function getOrCreateUserId(): string {
  if (typeof window === 'undefined') {
    // SSR - возвращаем временный ID
    return 'temp_user_' + Date.now();
  }

  let userId = localStorage.getItem(USER_ID_KEY);
  
  if (!userId) {
    // Генерируем новый уникальный ID
    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    localStorage.setItem(USER_ID_KEY, userId);
  }
  
  return userId;
}

export function getUserId(): string | null {
  if (typeof window === 'undefined') {
    return null;
  }
  return localStorage.getItem(USER_ID_KEY);
}
```

### Проверка существующего шара
```typescript
export async function getUserToy(userId: string): Promise<Toy | null> {
  try {
    const { data, error } = await supabase
      .from('toys')
      .select('*')
      .eq('user_id', userId)
      .maybeSingle();

    if (error || !data) {
      return null;
    }

    return data as Toy;
  } catch (err) {
    console.warn('Ошибка проверки существующего шара:', err);
    return null;
  }
}
```

